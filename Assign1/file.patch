diff -ruN xv6-public/.git/COMMIT_EDITMSG ../xv6-public/.git/COMMIT_EDITMSG
--- xv6-public/.git/COMMIT_EDITMSG	1970-01-01 05:30:00.000000000 +0530
+++ ../xv6-public/.git/COMMIT_EDITMSG	2022-09-05 20:10:29.798797900 +0530
@@ -0,0 +1 @@
+abc
diff -ruN xv6-public/.git/config ../xv6-public/.git/config
--- xv6-public/.git/config	2022-09-05 20:26:36.848797900 +0530
+++ ../xv6-public/.git/config	2022-08-06 13:38:10.660000000 +0530
@@ -4,7 +4,7 @@
 	bare = false
 	logallrefupdates = true
 [remote "origin"]
-	url = https://github.com/mit-pdos/xv6-public.git
+	url = https://github.com/mit-pdos/xv6-public
 	fetch = +refs/heads/*:refs/remotes/origin/*
 [branch "master"]
 	remote = origin
Binary files xv6-public/.git/index and ../xv6-public/.git/index differ
diff -ruN xv6-public/.git/logs/HEAD ../xv6-public/.git/logs/HEAD
--- xv6-public/.git/logs/HEAD	2022-09-05 20:26:36.848797900 +0530
+++ ../xv6-public/.git/logs/HEAD	2022-09-05 20:10:29.798797900 +0530
@@ -1 +1,2 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Anindya Vijayvargeeya <an.vijay.q@gmail.com> 1662389796 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 droid <droid@LAPTOP-2R7E8741.localdomain> 1659773290 +0530	clone: from https://github.com/mit-pdos/xv6-public
+eeb7b415dbcb12cc362d0783e41c3d1f44066b17 1e33d276aac037a47f94823e2ba4a4eb8bca4088 Anindya Vijayvargeeya <an.vijay.q@gmail.com> 1662388829 +0530	commit: abc
diff -ruN xv6-public/.git/logs/refs/heads/master ../xv6-public/.git/logs/refs/heads/master
--- xv6-public/.git/logs/refs/heads/master	2022-09-05 20:26:36.848797900 +0530
+++ ../xv6-public/.git/logs/refs/heads/master	2022-09-05 20:10:29.798797900 +0530
@@ -1 +1,2 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Anindya Vijayvargeeya <an.vijay.q@gmail.com> 1662389796 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 droid <droid@LAPTOP-2R7E8741.localdomain> 1659773290 +0530	clone: from https://github.com/mit-pdos/xv6-public
+eeb7b415dbcb12cc362d0783e41c3d1f44066b17 1e33d276aac037a47f94823e2ba4a4eb8bca4088 Anindya Vijayvargeeya <an.vijay.q@gmail.com> 1662388829 +0530	commit: abc
diff -ruN xv6-public/.git/logs/refs/remotes/origin/HEAD ../xv6-public/.git/logs/refs/remotes/origin/HEAD
--- xv6-public/.git/logs/refs/remotes/origin/HEAD	2022-09-05 20:26:36.848797900 +0530
+++ ../xv6-public/.git/logs/refs/remotes/origin/HEAD	2022-08-06 13:38:10.660000000 +0530
@@ -1 +1 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Anindya Vijayvargeeya <an.vijay.q@gmail.com> 1662389796 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 droid <droid@LAPTOP-2R7E8741.localdomain> 1659773290 +0530	clone: from https://github.com/mit-pdos/xv6-public
Binary files xv6-public/.git/objects/0c/9eb3740bcd406b598d6b508848613d80506565 and ../xv6-public/.git/objects/0c/9eb3740bcd406b598d6b508848613d80506565 differ
Binary files xv6-public/.git/objects/1e/33d276aac037a47f94823e2ba4a4eb8bca4088 and ../xv6-public/.git/objects/1e/33d276aac037a47f94823e2ba4a4eb8bca4088 differ
Binary files xv6-public/.git/objects/2a/71728f6eb9e67f2a72b8ab472fa2b7b6b3a68c and ../xv6-public/.git/objects/2a/71728f6eb9e67f2a72b8ab472fa2b7b6b3a68c differ
Binary files xv6-public/.git/objects/62/0ea238ede82cab3c32b2e2b0c62ff63f0d875e and ../xv6-public/.git/objects/62/0ea238ede82cab3c32b2e2b0c62ff63f0d875e differ
Binary files xv6-public/.git/objects/62/968ac0a2ac3c5eb5e72c254d98127c15a13aaf and ../xv6-public/.git/objects/62/968ac0a2ac3c5eb5e72c254d98127c15a13aaf differ
Binary files xv6-public/.git/objects/6f/e036ff619c05d1f805b0b4629d8e04b2a62fac and ../xv6-public/.git/objects/6f/e036ff619c05d1f805b0b4629d8e04b2a62fac differ
diff -ruN xv6-public/.git/objects/88/1c8bb36aaa05c8b084cc0129684509e6463fbe ../xv6-public/.git/objects/88/1c8bb36aaa05c8b084cc0129684509e6463fbe
--- xv6-public/.git/objects/88/1c8bb36aaa05c8b084cc0129684509e6463fbe	1970-01-01 05:30:00.000000000 +0530
+++ ../xv6-public/.git/objects/88/1c8bb36aaa05c8b084cc0129684509e6463fbe	2022-09-05 20:10:10.028797900 +0530
@@ -0,0 +1,2 @@
+xU‹Ë
+Â0Ý&_q‰	’ºQì§¨‹¼JmZò¨Šøï&+éî0gF³‚örÞí×c6Hz/6‚ÿ(&™6HŽ6T„O0Iç)û`TE§A2€Êýí$„xt-¡h=m9`SV9fWhÌÝ&È'¥ëìÌ•C-ëð¦mbQË]8²/—h_üLO:
Binary files xv6-public/.git/objects/8b/2f725e95a5df2232de774ebd3ca6bcaa3371b4 and ../xv6-public/.git/objects/8b/2f725e95a5df2232de774ebd3ca6bcaa3371b4 differ
Binary files xv6-public/.git/objects/94/0ede46f62ac35dcffda628e51e032a704b1fc7 and ../xv6-public/.git/objects/94/0ede46f62ac35dcffda628e51e032a704b1fc7 differ
Binary files xv6-public/.git/objects/b8/7fcffd6b7ad05ed889f003d26c64c6b101c83c and ../xv6-public/.git/objects/b8/7fcffd6b7ad05ed889f003d26c64c6b101c83c differ
Binary files xv6-public/.git/objects/be/721ae9b4364a68251c003883f1e8825ff95b5a and ../xv6-public/.git/objects/be/721ae9b4364a68251c003883f1e8825ff95b5a differ
Binary files xv6-public/.git/objects/e8/b4d5d7fd7c29bce24b669066b88dcb66e56763 and ../xv6-public/.git/objects/e8/b4d5d7fd7c29bce24b669066b88dcb66e56763 differ
Binary files xv6-public/.git/objects/ea/ab2bfcececf0f9d9af765a3d72a2cb14a0c8fb and ../xv6-public/.git/objects/ea/ab2bfcececf0f9d9af765a3d72a2cb14a0c8fb differ
Binary files xv6-public/.git/objects/ee/eeb5920514adfecd0bbd759df0c953460b591b and ../xv6-public/.git/objects/ee/eeb5920514adfecd0bbd759df0c953460b591b differ
diff -ruN xv6-public/.git/refs/heads/master ../xv6-public/.git/refs/heads/master
--- xv6-public/.git/refs/heads/master	2022-09-05 20:26:36.848797900 +0530
+++ ../xv6-public/.git/refs/heads/master	2022-09-05 20:10:29.798797900 +0530
@@ -1 +1 @@
-eeb7b415dbcb12cc362d0783e41c3d1f44066b17
+1e33d276aac037a47f94823e2ba4a4eb8bca4088
diff -ruN xv6-public/.vscode/settings.json ../xv6-public/.vscode/settings.json
--- xv6-public/.vscode/settings.json	1970-01-01 05:30:00.000000000 +0530
+++ ../xv6-public/.vscode/settings.json	2022-09-04 17:04:45.683239200 +0530
@@ -0,0 +1,10 @@
+{
+  "files.associations": {
+    "*.ejs": "html",
+    "spinlock.h": "c",
+    "user.h": "c",
+    "types.h": "c",
+    "defs.h": "c",
+    "proc.h": "c"
+  }
+}
\ No newline at end of file
diff -ruN xv6-public/Drawtest.c ../xv6-public/Drawtest.c
--- xv6-public/Drawtest.c	1970-01-01 05:30:00.000000000 +0530
+++ ../xv6-public/Drawtest.c	2022-08-12 21:32:29.977486200 +0530
@@ -0,0 +1,11 @@
+#include "types.h"
+#include "stat.h"
+#include  "user.h"
+
+int main(){
+	static char buf[2000];
+	printf(1, "return value : %d\n", draw((void*)buf, 2000));
+
+	printf(1, "%s", buf);
+	exit();
+}
diff -ruN xv6-public/Makefile ../xv6-public/Makefile
--- xv6-public/Makefile	2022-09-05 20:26:36.858797900 +0530
+++ ../xv6-public/Makefile	2022-08-30 01:02:09.700684300 +0530
@@ -181,6 +181,8 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_Drawtest\
+	_thread\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -250,7 +252,7 @@
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	printf.c umalloc.c Drawtest.c thread.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
Binary files xv6-public/_lotr and ../xv6-public/_lotr differ
diff -ruN xv6-public/defs.h ../xv6-public/defs.h
--- xv6-public/defs.h	2022-09-05 20:26:36.858797900 +0530
+++ ../xv6-public/defs.h	2022-08-30 00:58:43.970684300 +0530
@@ -120,6 +120,9 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int             thread_create(void(*)(void*), void*, void*);
+int             thread_join(void);
+void            thread_exit(void);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff -ruN xv6-public/proc.c ../xv6-public/proc.c
--- xv6-public/proc.c	2022-09-05 20:26:36.858797900 +0530
+++ ../xv6-public/proc.c	2022-09-05 20:24:29.878797900 +0530
@@ -532,3 +532,138 @@
     cprintf("\n");
   }
 }
+
+// create a new thread
+int thread_create( void(*fcn)(void*), void* arg, void* stack )
+{
+  int i, pid;
+  struct proc *np;
+  struct proc *curproc = myproc();
+
+  // Allocate process.
+  if((np = allocproc()) == 0){
+    return -1;
+  }
+
+  np->pgdir = curproc->pgdir;
+  np->sz = curproc->sz;
+  np->parent = curproc;
+  *np->tf = *curproc->tf;
+
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+
+  // Set eip instruction pointer to fcn 
+  np->tf->eip = (uint)fcn;
+
+  // and esp to stack
+  np->tf->esp = (uint)stack + 4096;
+  // put arg on stack
+  np->tf->esp -= 4;
+  *((uint*)np->tf->esp) = (uint)arg;
+  np->tf->esp -= 4;
+  *((uint*)np->tf->esp) = 0xffffffff;
+
+
+  for(i = 0; i < NOFILE; i++)
+    if(curproc->ofile[i])
+      np->ofile[i] = filedup(curproc->ofile[i]);
+  np->cwd = idup(curproc->cwd);
+
+  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+
+  pid = np->pid;
+
+  acquire(&ptable.lock);
+
+  np->state = RUNNABLE;
+
+  release(&ptable.lock);
+
+  return pid;
+}
+
+int thread_join(void)
+{
+  struct proc *p;
+  int havekids, pid;
+  struct proc *curproc = myproc();
+  
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != curproc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        // same as wait but we don't want to clear up page table
+        // freevm(p->pgdir);
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        p->state = UNUSED;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || curproc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+
+void thread_exit(void)
+{
+  struct proc *curproc = myproc();
+  struct proc *p;
+  int fd;
+
+  if(curproc == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd]){
+      fileclose(curproc->ofile[fd]);
+      curproc->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(curproc->cwd);
+  end_op();
+  curproc->cwd = 0;
+
+  acquire(&ptable.lock);
+
+  // Parent might be sleeping in wait().
+  wakeup1(curproc->parent);
+
+  // Pass abandoned children to init.
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->parent == curproc){
+      p->parent = initproc;
+      if(p->state == ZOMBIE)
+        wakeup1(initproc);
+    }
+  }
+
+  // Jump into the scheduler, never to return.
+  curproc->state = ZOMBIE;
+  sched();
+  panic("zombie exit");
+}
+
diff -ruN xv6-public/syscall.c ../xv6-public/syscall.c
--- xv6-public/syscall.c	2022-09-05 20:26:36.868797900 +0530
+++ ../xv6-public/syscall.c	2022-08-30 00:43:54.050684300 +0530
@@ -103,6 +103,10 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_draw(void);
+extern int sys_thread_create(void);
+extern int sys_thread_join(void);
+extern int sys_thread_exit(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +130,10 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_draw]    sys_draw,
+[SYS_thread_create]  sys_thread_create,
+[SYS_thread_join]  sys_thread_join,
+[SYS_thread_exit]  sys_thread_exit,
 };
 
 void
diff -ruN xv6-public/syscall.h ../xv6-public/syscall.h
--- xv6-public/syscall.h	2022-09-05 20:26:36.868797900 +0530
+++ ../xv6-public/syscall.h	2022-08-30 00:44:42.650684300 +0530
@@ -20,3 +20,8 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_draw   22
+#define SYS_thread_create   23
+#define SYS_thread_join     24
+#define SYS_thread_exit     25
+
diff -ruN xv6-public/sysproc.c ../xv6-public/sysproc.c
--- xv6-public/sysproc.c	2022-09-05 20:26:36.868797900 +0530
+++ ../xv6-public/sysproc.c	2022-08-30 00:49:05.750684300 +0530
@@ -89,3 +89,56 @@
   release(&tickslock);
   return xticks;
 }
+
+int sys_draw(void){
+	void* buf;
+	uint size;
+	argptr(0, (void*)&buf, sizeof(buf));
+	argptr(1, (void*)&size, sizeof(size));
+	char text[] = 
+"         ___ . .  _\n"
+" T$$$P    |  |_| |_\n"
+" :$$$     |  | | |_\n"
+" :$$$                                                      `T$$$$$$$b. \n"
+" :$$$     .g$$$$$p.   T$$$$b.    T$$$$$bp.                   BUG    `Tb      T$b      T$P   .g$P^^T$$  ,gP^^T$$ \n"
+"  $$$    d^`     `^b   $$  `Tb    $$    `Tb    .s^s. :sssp   $$$     :$; T$$P $^b.     $   dP`     `T :$P    `T \n"
+"  :$$   dP         Tb  $$   :$;   $$      Tb  d'   `b $      $$$     :$;  $$  $ `Tp    $  d$           Tbp. \n"
+"  :$$  :$;         :$; $$   :$;   $$      :$; T.   .P $^^    $$$    .dP   $$  $   ^b.  $ :$;            `T$$p.   \n"
+"  $$$  :$;         :$; $$...dP    $$      :$;  `^s^' .$.     $$$...dP`    $$  $    `Tp $ :$;     `T$$      `T$b  \n"
+"  $$$   Tb.       ,dP  $$```Tb    $$      dP ``$``$` `$`$^^  $$$``T$b     $$  $      ^b$  T$       T$ ;      $$; \n"
+"  $$$    Tp._   _,gP   $$   `Tb.  $$    ,dP    $  $...$ $..  $$$   T$b    :$  $       `$   Tb.     :$ T.    ,dP  \n"
+"  $$$;    `^$$$$$^`   d$$     `T.d$$$$$P^`     $  $```$ $``, $$$    T$b  d$$bd$b      d$b   `^TbsssP` 'T$bgd$P   \n"
+"  $$$b.____.dP                                 $ .$. .$.$ss,d$$$b.   T$b.                                        \n"
+".d$$$$$$$$$$P                                                         `T$b.                                      \n" ;
+	if(sizeof(text) > size) {
+		return -1;
+	};
+
+	strncpy((char*) buf, text, size);
+	return sizeof(text);
+}
+
+int sys_thread_create(void) {
+  int fcn;
+  char* arg;
+  char* stack;
+  if (argint(0, &fcn) < 0)
+    return -1;
+  if (argstr(1, &arg) < 0)
+    return -1;
+  if (argstr(2, &stack) < 0)
+    return -1;
+  return thread_create((void(*)(void*))fcn, arg, stack);
+}
+
+int sys_thread_exit(void)
+{
+  thread_exit();
+  return 0;
+}
+
+int sys_thread_join(void)
+{
+  return thread_join();
+}
+
diff -ruN xv6-public/thread.c ../xv6-public/thread.c
--- xv6-public/thread.c	1970-01-01 05:30:00.000000000 +0530
+++ ../xv6-public/thread.c	2022-09-05 18:40:12.708797900 +0530
@@ -0,0 +1,167 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "x86.h"
+
+
+struct thread_spinlock {
+  uint locked;       // Is the lock held?
+};
+
+struct thread_spinlock lock;
+
+// initialize the lock
+void thread_spin_init(struct thread_spinlock *lk)
+{
+  lk->locked = 0;
+}
+
+// Acquire the lock.
+// Loops (spins) until the lock is acquired.
+// Holding a lock for a long time may cause
+// other CPUs to waste time spinning to acquire it.
+void
+thread_spin_lock(struct thread_spinlock *lk)
+{
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+
+}
+
+// Release the lock.
+void thread_spin_unlock(struct thread_spinlock *lk)
+{
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that all the stores in the critical
+  // section are visible to other cores before the lock is released.
+  // Both the C compiler and the hardware may re-order loads and
+  // stores; __sync_synchronize() tells them both not to.
+  __sync_synchronize();
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+
+}
+
+
+
+//////////////////////////////////////////////////////////////////
+
+struct thread_mutex {
+  uint locked;       // Is the lock held?
+};
+
+struct thread_mutex mutex;
+
+// initialize the lock
+void thread_mutex_init(struct thread_mutex *lk)
+{
+  lk->locked = 0;
+}
+
+// Acquire the lock.
+// Loops (spins) until the lock is acquired.
+// Holding a lock for a long time may cause
+// other CPUs to waste time spinning to acquire it.
+void
+thread_mutex_lock(struct thread_mutex *lk)
+{
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    sleep(1);
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+
+}
+
+// Release the lock.
+void thread_mutex_unlock(struct thread_mutex *lk)
+{
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that all the stores in the critical
+  // section are visible to other cores before the lock is released.
+  // Both the C compiler and the hardware may re-order loads and
+  // stores; __sync_synchronize() tells them both not to.
+  __sync_synchronize();
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+
+}
+
+//////////////////////////////////////////////////////////////////
+
+struct balance 
+{
+ char name[32];
+ int amount;
+};
+volatile int total_balance = 0;
+volatile unsigned int delay (unsigned int d) 
+{
+ unsigned int i; 
+ for (i = 0; i < d; i++) 
+ {
+ __asm volatile( "nop" ::: );
+ }
+ return i; 
+}
+void do_work(void *arg)
+{
+ int i; 
+ int old;
+ struct balance *b = (struct balance*) arg; 
+ printf(1, "Starting do_work: s:%s\n", b->name);
+ for (i = 0; i < b->amount; i++) 
+ { 
+//  thread_spin_lock(&lock); 
+thread_mutex_lock(&mutex);
+ old = total_balance;
+ delay(100000);
+ total_balance = old + 1;
+//  thread_spin_unlock(&lock); 
+thread_mutex_unlock(&mutex);
+ }
+ printf(1, "Done s:%x\n", b->name);
+ thread_exit();
+ return;
+}
+
+int main(int argc, char *argv[]) {
+
+  ////////////////////////
+  // Initialize the lock
+  ////////////////////////
+  
+  thread_spin_init(&lock);
+  thread_mutex_init(&mutex);
+
+ struct balance b1 = {"b1", 3200};
+ struct balance b2 = {"b2", 2800};
+ void *s1, *s2;
+ int t1, t2, r1, r2;
+ s1 = malloc(4096);
+ s2 = malloc(4096);
+ t1 = thread_create(do_work, (void*)&b1, s1);
+ t2 = thread_create(do_work, (void*)&b2, s2);
+ r1 = thread_join();
+ r2 = thread_join();
+ printf(1, "Threads finished: (%d):%d, (%d):%d, shared balance:%d\n",
+ t1, r1, t2, r2, total_balance);
+ exit();
+}
diff -ruN xv6-public/user.h ../xv6-public/user.h
--- xv6-public/user.h	2022-09-05 20:26:36.868797900 +0530
+++ ../xv6-public/user.h	2022-08-30 00:54:25.670684300 +0530
@@ -23,6 +23,10 @@
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int draw(void*, uint);
+int thread_create(void(*)(void*), void*, void*);
+int thread_join(void);
+void thread_exit(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff -ruN xv6-public/usys.S ../xv6-public/usys.S
--- xv6-public/usys.S	2022-09-05 20:26:36.868797900 +0530
+++ ../xv6-public/usys.S	2022-08-30 00:54:47.460684300 +0530
@@ -29,3 +29,7 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(draw)  
+SYSCALL(thread_create)
+SYSCALL(thread_join)
+SYSCALL(thread_exit)
